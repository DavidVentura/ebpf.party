---
layout: ../../layouts/ExerciseLayout.astro
title: Getting a process name
codeFile: ex1.c
exerciseId: exercise-1
---

# {frontmatter.title}

Welcome to the first challenge!

<details>
<summary>Here's a short refresher of the eBPF concepts seen [in the tutorial]().</summary>

eBPF allows us to attach arbitrary programs to specific points in the Kernel.

To see what's available:

```bash
sudo ls /sys/kernel/debug/tracing/events/
block dev sock syscalls tcp ...
```

Each tracepoint takes a single argument, with a dedicated struct type.

The tracepoint is invoked _before the start_ of the kernel function.
</details>

<details>
<summary>And a short refresher of the [platform capabilities]().</summary>

There are some `DEBUG_` macros that will show values directly in this UI.
```c
DEBUG_U32("A label", var);
DEBUG_U64("Label", var_u64);
DEBUG_STR("Label", var_str);
DEBUG_STRUCT("Label", var_struct);
```
The label is only for the UI.
</details>

## The challenge
Extract the name of programs being executed on the target system. 

We only care for the program that contains "ctf" in its name.

## Some context

When a process is first executed (via the [exec syscall family](https://man7.org/linux/man-pages/man2/execve.2.html)),
the scheduler is notified about the event, to, well, schedule the process.

If we check the exposed scheduler events, we'll find a bunch
```bash
$ ls /sys/kernel/debug/tracing/events/sched
sched_migrate_task sched_process_exec sched_process_fork ...
```

here `sched_process_exec` looks very promising, but to be sure, we need to see
what information is available to this tracepoint.

```bash
$ cat /sys/kernel/debug/tracing/events/sched/sched_process_exec/format
format:
  unsigned short common_type;           offset:0;   size:2;
  unsigned char common_flags;           offset:2;   size:1;
  unsigned char common_preempt_count;   offset:3;   size:1;
  int common_pid;                       offset:4;   size:4;
  __data_loc char[] filename;           offset:8;   size:4;
  pid_t pid;                            offset:12;  size:4;
  pid_t old_pid;                        offset:16;  size:4;
```

Perfect, the event receives `filename`!
{/* 
<small>
Note that you can also `Ctrl`+`click` on the `trace_event_raw_sched_process_exec` in the editor to see the definition
</small> */}

However, notice that it's not a regular pointer, the `__data_loc` prefix means it's not the actual string,
but metadata on how to find it.

Essentially, the `filename` field contains only 4 bytes, which could be better understood as

```c
struct __data_loc {
    u16 length; // upper 16 bits: length of data
    u16 offset; // lower 16 bits: offset from start of ctx
}
```

so the _actual_ content is at `ctx + offset`.

```
[  Ctx Struct (Fixed Size)  ]        [  Dynamic Data Area  ]
+---------------------------+        +---------------------+
| pid (4b) | ... | filename | ...... | "bash\0"            |
+---------------------------+        +---------------------+
                     |                  ^
                     |                  |
                     +--- offset -------+
```




Remember that in eBPF context, we can't read user data directly, so we need to use a helper:

```c
// Read the encoded location
u32 loc = BPF_CORE_READ(ctx, filename);
u16 offset = loc & 0xFFFF;
const char *filename = (char *)ctx + offset;
```

## Your task

Complete the provided program. You get extra points if you only return the filtered program names,
[bpf_strstr](https://docs.ebpf.io/linux/kfuncs/bpf_strstr/) is your friend.



{/*
<details>
<summary>Excessive details on `__data_loc` definition</summary>
You can find that the `__data_loc` prefix is prepended in the [__dynamic_array macro](https://github.com/torvalds/linux/blob/v6.18/include/trace/stages/stage4_event_fields.h#L33-L36).
```c
#define __dynamic_array(_type, _item, _len) {				\
	.type = "__data_loc " #_type "[]", .name = #_item,		\
	.size = 4, .align = 4,						\
	.is_signed = is_signed_type(_type), .filter_type = FILTER_OTHER },
```
which is part of the machinery that generates the tracing format we saw before.

For the actual runtime behavior, see the [sched_process_exec tracepoint definition](https://github.com/torvalds/linux/blob/v6.18/include/trace/events/sched.h#L438) 
which uses `__string()` to declare the field and `__assign_str()` to populate it.

The `__assign_str` macro copies the string to a buffer and encodes the offset + length into that 4-byte `filename` field.
</details>
*/}