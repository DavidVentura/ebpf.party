---
layout: ../../../layouts/ExerciseLayout.astro
title: Reading from specific files
codeFile: 2_read_file_password.c
exerciseId: read-file-password
---

In the previous exercise, we captured _all_ `read()` calls. But what if we only care about reads from a specific file, like `/tmp/password`?

The problem: `read()` operates on file descriptors, not filenames. When a process calls `open("/tmp/password")`, the kernel returns a file descriptor (fd) — a per-process unique number like `4`. Subsequent read calls use that number (`read(4, buf, ...)`).

By the time we see the `read()` syscall, we only have access to the fd number. The filename is gone.

To filter reads by filename, we need to correlate the `open()` and `read()` syscalls: track which fds correspond to `/tmp/password` at open time, then use that information when intercepting reads.

## Multi-syscall correlation

We need to track state across four separate eBPF program invocations:

1. `sys_enter_open` - Check if the pathname is `/tmp/password`
2. `sys_exit_open` - Get the returned fd if it was our file
3. `sys_enter_read` - Check if the fd being read is one we're tracking
4. `sys_exit_read` - Read the buffer contents and submit

This requires three maps with different lifetimes:

**Map 1: `open_curr_fd_interesting`** (`PID → marker`)
- Lifetime: `open_entry` → `open_exit` only
- Temporary marker for PIDs currently opening `/tmp/password`
- Uses simple `pid` key because the thread is blocked during the syscall

**Map 2: `open_interesting_fds`** (`(PID, FD) → marker`)
- Lifetime: Persists across syscalls
- Tracks which `(pid, fd)` pairs correspond to `/tmp/password`
- Requires compound key because a process can have multiple fds open

**Map 3: `read_curr_fd_buf`** (`PID → buffer pointer`)
- Lifetime: `read_entry` → `read_exit` only
- Temporary storage for buffer pointer during read
- Uses simple `pid` key because the thread is blocked during the syscall

## Map key design

The choice between simple and compound keys depends on the map's lifetime:

**Temporary maps** (within a single syscall) can use `PID` alone as the key. When a thread enters a syscall, it blocks until the syscall completes. During this time, that thread cannot execute any other code, including making another syscall.

**Persistent maps** (across syscalls) require compound keys like `(PID, FD)`. After a syscall completes, the thread continues execution and can make other syscalls. A process can have multiple file descriptors open simultaneously, so fd `4` might point to `/tmp/password` while fd `5` points to `/etc/config`. The key must be a unique identifier in the domain we are operating.


## The challenge

A program opens and reads multiple files. Only `/tmp/password` contains the password.

Implement the four eBPF programs according to the TODOs in the starter code:

1. `trace_open_entry` - Read pathname, check if it's `/tmp/password`, mark the PID
2. `trace_open_exit` - If PID is marked, store `(pid, fd)` in the persistent map
3. `trace_read_entry` - If `(pid, fd)` exists, store the buffer pointer
4. `trace_read_exit` - Read buffer contents and submit with `SUBMIT_STR_LEN`

**Hints:**
- Use `bpf_strncmp(pathname, 64, "/tmp/password") == 0` to match the filename
- Check all map lookups for NULL before dereferencing
- Clean up temporary maps after use (`open_curr_fd_interesting`, `read_curr_fd_buf`)
- The persistent map `open_interesting_fds` can remain
