---
layout: ../../../layouts/ExerciseLayout.astro
title: Reading syscall buffers
codeFile: 1_read_buffer.c
exerciseId: read-buffer-contents
---

In the previous exercise, we learned how to use maps to share data between multiple eBPF programs.

Now let's apply this to capturing data from syscall buffers. Syscalls have two tracepoint types: `enter` (before it starts) and `exit` (after it finishes). We'll need to correlate data between both.

## The read syscall

Looking at the [read syscall](https://man7.org/linux/man-pages/man2/read.2.html):

```c
ssize_t read(int fd, void *buf, size_t count);
```

If we hook into `sys_enter_read` and `sys_exit_read`:

- At **entry**: we have access to the arguments, but the buffer is still empty.
- At **exit**: the buffer is filled with data, but we only have access to the return value.

To correlate both, we capture the buffer pointer at entry using a map, then read the filled buffer at exit.

## The entry program

At entry, we save the buffer pointer in a map, keyed by PID:

```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u64);    // PID
    __type(value, u64);  // Buffer pointer
} read_buffers SEC(".maps");

SEC("tracepoint/syscalls/sys_enter_read")
int trace_read_entry(struct trace_event_raw_sys_enter *ctx)
{
    u64 pid = bpf_get_current_pid_tgid();
    u64 buf_ptr = ctx->args[1];  // The buffer pointer

    bpf_map_update_elem(&read_buffers, &pid, &buf_ptr, BPF_ANY);
    return 0;
}
```

## The challenge

A program reads a file containing a password. Submit the contents of the entire file with `SUBMIT_STR_LEN`.

### Your task

Write the `exit` program to capture the buffer contents.

You will need to:
1. Check if the read succeeded (`ctx->ret > 0`)
   - The return value indicates how many bytes were read
2. Look up the buffer pointer we stored with `bpf_map_lookup_elem` and the PID as key
    - Check if you get a value or NULL
3. Create a local buffer on the stack
4. Read the now-filled buffer from user space
   - Limit count to your buffer size (e.g., `if (count > 64) count = 64`)


Remember that we are storing the address of the buffer in the map (as `u64`), so `bpf_map_lookup_elem` returns a pointer to the value (`u64*`). You'll need to de-reference the pointer in your call to `bpf_probe_read_user`:

```c
u64 *buf_ptr = bpf_map_lookup_elem(&read_buffers, &pid);
// ...
bpf_probe_read_user(local_buf, count, (void *)*buf_ptr)
```