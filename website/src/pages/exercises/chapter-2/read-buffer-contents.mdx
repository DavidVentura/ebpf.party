---
layout: ../../../layouts/ExerciseLayout.astro
title: Reading syscall buffers
codeFile: 1_read_buffer.c
exerciseId: read-buffer-contents
---

In the previous exercise, we learned how to use maps to share data between multiple eBPF programs.

Now let's apply this technique to a more complex scenario: capturing data from syscall buffers.

## The problem

Consider the `read()` syscall:

```c
ssize_t read(int fd, void *buf, size_t count);
```

When `read()` is **called** (entry), the buffer is empty.
When `read()` **returns** (exit), the buffer is filled with data.

We need to:
1. At **entry**: Save the buffer pointer
2. At **exit**: Read the filled buffer

## Syscall entry and exit

Syscalls have two tracepoint types: `enter` and `exit`, which execute before the syscall starts and after it finishes.

**At entry (`sys_enter_*`):**
- Context type: `struct trace_event_raw_sys_enter`
- Available: `args[6]` - the syscall arguments

**At exit (`sys_exit_*`):**
- Context type: `struct trace_event_raw_sys_exit`
- Available: `ret` - the return value only

To correlate data between entry and exit, we use maps (as we learned in the previous exercise).

## The read syscall

Looking at the [read manual](https://man7.org/linux/man-pages/man2/read.2.html):

```c
ssize_t read(int fd, void *buf, size_t count);
```

**Arguments (available at entry):**
- `ctx->args[0]` - file descriptor
- `ctx->args[1]` - pointer to destination buffer
- `ctx->args[2]` - max bytes to read

**Return value (available at exit):**
- `ctx->ret` - Number of bytes read (or negative on error, 0 on EOF)

## The entry program

At entry, we save the buffer pointer in a map, keyed by PID:

```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u64);    // PID
    __type(value, u64);  // Buffer pointer
} read_buffers SEC(".maps");

SEC("tracepoint/syscalls/sys_enter_read")
int trace_read_entry(struct trace_event_raw_sys_enter *ctx)
{
    u64 pid = bpf_get_current_pid_tgid();
    u64 buf_ptr = ctx->args[1];  // The buffer pointer

    bpf_map_update_elem(&read_buffers, &pid, &buf_ptr, BPF_ANY);
    return 0;
}
```

## The challenge

A program reads a file containing a password. Submit the entire file contents with `SUBMIT_STR_LEN`.

### Your task

Write the exit program to capture the buffer contents.

You will need to:
1. Check if the read succeeded (`ctx->ret > 0`)
   - The return value indicates how many bytes were read
2. Look up the buffer pointer we stored (using the same PID)
3. Create a local buffer on the stack
4. Read the now-filled buffer from user space
   - Use `bpf_probe_read_user(local_buf, count, (void *)*buf_ptr)`
   - Note the dereference: `*buf_ptr` (map lookup returns a pointer)
   - Limit count to your buffer size (e.g., `if (count > 64) count = 64`)
5. Submit your answer with `SUBMIT_STR_LEN(data, count)`

**Hint:** Use `DEBUG_STR` to see what's being read from various files.
