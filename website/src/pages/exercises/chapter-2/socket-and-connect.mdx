---
layout: ../../../layouts/ExerciseLayout.astro
title: Tracking network connections
codeFile: 3_socket_connect.c
exerciseId: socket-and-connect
---

Now let's apply map correlation to network sockets!

When a program makes a network connection:
1. `socket()` creates a socket â†’ returns socket fd
2. `connect(fd, addr, ...)` connects using that fd

We'll track socket creation, then intercept connection attempts.

## The socket syscall

```c
int socket(int domain, int type, int protocol);
```

- Returns: socket file descriptor
- We'll track this fd in a map

## The connect syscall

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

The `addr` structure for IPv4:

```c
struct sockaddr_in {
    u16 sin_family;  // AF_INET = 2
    u16 sin_port;    // Port (network byte order!)
    u32 sin_addr;    // IP address (network byte order!)
    char __pad[8];
};
```

**Important:** Port and IP are in **network byte order** (big-endian).

Convert to host order:
```c
u16 port = bpf_ntohs(addr.sin_port);     // Network to host (16-bit)
u32 ip = bpf_ntohl(addr.sin_addr.s_addr); // Network to host (32-bit)
```

## The pattern

```c
// Track socket fds
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u32);   // socket fd
    __type(value, u8);  // flag (1 = tracked)
} tracked_sockets SEC(".maps");

// At socket creation
SEC("tracepoint/syscalls/sys_exit_socket")
int trace_socket_exit(struct trace_event_raw_sys_exit *ctx)
{
    if (ctx->ret < 0) return 0;
    u32 sockfd = ctx->ret;
    u8 flag = 1;

    bpf_map_update_elem(&tracked_sockets, &sockfd, &flag, BPF_ANY);
    return 0;
}

// At connect
SEC("tracepoint/syscalls/sys_enter_connect")
int trace_connect_entry(struct trace_event_raw_sys_enter *ctx)
{
    u32 sockfd = ctx->args[0];

    // Check if we're tracking this socket
    u8 *tracked = bpf_map_lookup_elem(&tracked_sockets, &sockfd);
    if (!tracked) return 0;

    // Read sockaddr structure
    struct sockaddr_in addr;
    bpf_probe_read_user(&addr, sizeof(addr), (void *)ctx->args[1]);

    if (addr.sin_family == 2) {  // AF_INET
        u16 port = bpf_ntohs(addr.sin_port);
        DEBUG_NUM("Port", port);
    }

    return 0;
}
```

## The challenge

A program creates a socket and connects to a suspicious port.

Your task:

1. Define a map to track socket fds
2. In `socket` exit: Store the socket fd in the map
3. In `connect` entry:
   - Check if fd is tracked
   - Read the `sockaddr_in` structure
   - Verify `sin_family == 2` (IPv4)
   - Extract and convert the port number
   - Submit the suspicious port with `SUBMIT_NUM(port)`

**Hints:**
- You'll see connections to common ports (22, 80, 443)
- The suspicious port will stand out
- Use `DEBUG_NUM` to see all connection attempts
