---
layout: ../../../layouts/ExerciseLayout.astro
title: From program arguments
codeFile: 1_execve_argv.c
exerciseId: ex-3-1
---

import ExecveArgs from '../../../components/ExecveArgs.tsx';

In the previous exercise, you learned how to read the `filename` argument from the `execve` system call using `ctx->args[0]`.

Now let's explore the second argument: `argv`.

## Understanding argv

When you run a command like:
```bash
./secret_app --password hunter2
```

The kernel receives an array of arguments:
- `argv[0]` = `"./secret_app"`
- `argv[1]` = `"--password"`
- `argv[2]` = `"hunter2"`
- `argv[3]` = `NULL` (terminator)

Looking at the [execve manual page](https://man7.org/linux/man-pages/man2/execve.2.html):

```c
int execve(const char *filename, char *const argv[], char *const envp[]);
```

The second parameter, `argv`, is located at `ctx->args[1]`.

Unlike `filename`, which was a simple pointer to a string, `argv` and `envp` are **pointers to an array of pointers**.

<ExecveArgs
label="ctx->args"
args={[
    {
    index: 0,
    name: "args[0]",
    isSimplePointer: true,
    simpleValue: "secret_app\\0",
    subtitle: "char* filename"
    },
    {
    index: 1,
    name: "args[1]",
    subtitle: "char* argv[]",
    arrayValues: [
        { name: "argv[0]", pointsTo: "./secret_app\\0" },
        { name: "argv[1]", pointsTo: "--password\\0" },
        { name: "argv[2]", pointsTo: "hunter2\\0" },
        { name: "NULL", isNull: true }
    ]
    },
    {
    index: 2,
    name: "args[2]",
    subtitle: "char* envp[]",
    arrayValues: [
        { name: "envp[0]", pointsTo: "PATH=/usr/bin" },
        { name: "envp[1]", pointsTo: "HOME=/home" },
        { name: "NULL", isNull: true }
    ]
    }
]}
/>

As you can see in the diagram, `argv` and `envp` are terminated by a NULL pointer.

When you read an entry from the `argv` array (e.g., `argv[i]`), you must check if the value is `NULL`. If it is, you must not continue reading past the end.

## Reading the array of pointers

To read `argv`, we need to:

1. Get the argv pointer from `ctx->args[1]`
2. Cast it from `unsigned long` to `char **`
3. Read each pointer in the array (from **user space**)
4. For each pointer, read the string it points to (also from **user space**)

Here's the basic structure:

```c
// Get the argv pointer
char **argv = (char **)ctx->args[1];

// In a loop, read the next pointer from the array
char *arg_ptr;
bpf_probe_read_user(&arg_ptr, sizeof(arg_ptr), &argv[i]);
// remember to check for the NULL terminator!

// Read the string that pointer points to
char arg_buf[64];
bpf_probe_read_user_str(arg_buf, sizeof(arg_buf), arg_ptr);
```


## The challenge

A suspicious program is being executed with a `--password` flag followed by the actual password.

Your task is to:

1. Iterate through the `argv` array (up to 20 arguments max)
2. Find the argument that contains `"--password"`
3. Read the **next** argument, which contains the actual password
4. Print it using `DEBUG_STR`

**Hints:**
- Compare strings using the [bpf_strncmp(char* s1, u32 s1_sz, const char* s2)](https://docs.ebpf.io/linux/helper-function/bpf_strncmp/) helper
    - `s2` must be a literal in the source code
    - `bpf_strncmp` returns **0 on a match**
- Stop when you find a NULL pointer (end of argv)
- The eBPF verifier requires loops to have a maximum bound
