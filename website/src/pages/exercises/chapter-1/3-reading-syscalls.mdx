---
layout: ../../../layouts/ExerciseLayout.astro
title: Tracing a system call
codeFile: 3_execve_syscall.c
exerciseId: reading-syscalls
---
import ExecveArgs from '../../../components/ExecveArgs.tsx';


In the previous exercises, we hooked into the scheduler (`sched_process_exec`). This event fires *after* the kernel has loaded a binary and populated its internal structures.

But what happens *before* that? When a program like `bash` wants to run `ls`, it makes a request to the kernel through the `execve` system call.

System calls are different from the specific tracepoints we've used so far. They use generic `entry` and `exit` events that work for all syscalls.

## The generic syscall structure

Because there are _hundreds_ of system calls (`open`, `write`, `execve`...), each with its own set of arguments, the kernel uses a generic structure for tracepoints.

On entry events, we receive a context with type `struct trace_event_raw_sys_enter`:

```c
struct trace_event_raw_sys_enter {
    long int id;               /* The Syscall Number */
    long unsigned int args[6]; /* The Arguments */
    /* ... */
};
```

We don't get convenient fields like `name` or `pid` -- all we are getting is the syscall number (`id`) and an array of integers, `args[6]`, which are the arguments to the system call.

Why 6? Because that's the maximum number of arguments that syscalls are allowed to take.

We _also_ are not getting any types! All arguments are `long unsigned int` (`u64`), and it's up to us to interpret them properly (as pointers, structs, signed numbers, or even `u64`!).

To know the type and meaning of each argument, we can consult the [manual page](https://man7.org/linux/man-pages/man2/execve.2.html), which shows the signature:

```c
int execve(const char *filename, char *const argv[], char *const envp[]);
```

Since `filename` is the first argument, it's located at `ctx->args[0]`. The `args` array stores it as an `unsigned long`, so we'll need to cast it to `const char *`.

Something like this:

<ExecveArgs
label="ctx->args"
args={[
    {
    index: 0,
    name: "args[0]",
    isSimplePointer: true,
    simpleValue: "\"secret_app\\0\"",
    subtitle: "char* filename"
    },
    {
    index: 1,
    name: "args[1]",
    subtitle: "char* argv[]",
    isSimplePointer: true,
    simpleValue: "argv[]",
    },
    {
    index: 2,
    name: "args[2]",
    subtitle: "char* envp[]",
    isSimplePointer: true,
    simpleValue: "envp[]",
    }
]}
/>

But there's one more detail to handle.


### On address spaces

`ctx->args[0]` points to memory owned by the calling process (e.g., `bash`), which is **user space** memory.

The kernel enforces strict separation between user and kernel memory for security. This means we cannot use the kernel-space helpers we've used before (like `bpf_probe_read_kernel_str`) to read this data. Instead, we must use [bpf_probe_read_user_str(dst, size, src)](https://docs.ebpf.io/linux/helper-function/bpf_probe_read_user_str/).

## Your task

1. Construct the filename pointer from `ctx->args[0]`.
2. Read the string from **User Space** into a local buffer.

If you use `DEBUG_STR` on the buffer, you should see multiple programs being executed, 
remember that you can only submit _one_ answer with `SUBMIT_STR_LEN`, so you will need to filter them like we did in the previous exercises, with `bpf_strncmp(char* s1, u32 s1_size, const char* s2)`.

Where do you get `len`? Well, `bpf_probe_read_user_str` conveniently returns how many bytes it copied!