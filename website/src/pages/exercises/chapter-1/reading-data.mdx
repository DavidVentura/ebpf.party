---
layout: ../../../layouts/ExerciseLayout.astro
title: Reading event data
codeFile: 1_2_event_data.c
exerciseId: ex-1-2
---

# {frontmatter.title}


In the previous exercise, we cheated a little bit by using a helper to ask "Who is running?".

Let's now try to answer questions about the running process, by querying the data available to the tracepoint.

For `sched_process_exec`, the kernel provides a structure with specific event data, like the Process ID (PID) and the filename.

We can find the format of the context that the kernel provides on any Linux computer, by running:
```bash
$ cat /sys/kernel/debug/tracing/events/sched/sched_process_exec/format
format:
  unsigned short common_type;           offset:0;   size:2;
  unsigned char common_flags;           offset:2;   size:1;
  unsigned char common_preempt_count;   offset:3;   size:1;
  int common_pid;                       offset:4;   size:4;
  __data_loc char[] filename;           offset:8;   size:4;
  pid_t pid;                            offset:12;  size:4;
  pid_t old_pid;                        offset:16;  size:4;
```

Alternatively, `Ctrl`+`click` on the `trace_event_raw_sched_process_exec` in the editor to see the definition.

## The challenge
Extract the **PID** and the **filename** of the program being executed, directly from the event data.

Getting the PID is straightforward in this case, we can just read it:
```c
int pid = ctx->pid;
DEBUG_NUM("PID", pid);
```

Reading the filename, however, is a little bit more involved. If you look at the type declaration,
it is `__data_loc char[]`.

This is not a regular pointer; the `__data_loc` prefix means the field just contains
 the **location of the string**, not the string itself.

Basically, the filename field contains a 32-bit integer that packs two pieces of information:

  - Lower 16 bits: The Offset (How far away the string is from the start of the structure).
  - Upper 16 bits: The Length (How long the string is).

In memory, it'd look something like this:
```
[  Ctx Struct (Fixed Size)       ]        [  Dynamic Data Area  ]
+--------------------------------+        +---------------------+
| pid (4b) | ... | length|offset | ...... | "bash\0"            |
+--------------------------------+        +---------------------+
^                                            ^
|                                            |
+-------------------- offset ----------- ----+
```

To get the actual string, we have to do a little work:

  1. Read the `__data_loc_filename` field
  2. Mask the lower 16 bits (`val & 0xFFFF`) to get the offset
  3. Add that offset to the `ctx` pointer

However, we can't really read the data directly like this:

```c
char* fname = (void *)ctx + off;
```

Why not?

eBPF programs run in a sandbox, and calculated addresses like this one (`ctx + off`) point to Kernel memory (not the program's stack).

When we call `DEBUG_STR` with a non-local address, the Kernel helpers that are used will just return uninitialized memory.

You can try it though! It will not crash the kernel, instead, it will return something like: ` �����`.

To solve this, we need to copy that data to "local memory" (stack) using the [bpf_probe_read_kernel_str](https://docs.ebpf.io/linux/helper-function/bpf_probe_read_kernel_str/) helper.

```c
char fname[16];
bpf_probe_read_kernel_str(fname, sizeof(fname), (void *)ctx + off);
```
## Your task

Read the filename from the 

{/* 

```verifier
9: (85) call bpf_get_current_task#35          ; R0=scalar()
;  @ <stdin>:65
10: (79) r1 = *(u64 *)(r0 +2504)
R0 invalid mem access 'scalar'
processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 0
-- END PROG LOAD LOG --
libbpf: prog 'handle_exec': failed to load: -EACCES
libbpf: failed to load object '7f3a6cc81050-25a8'
``` */}